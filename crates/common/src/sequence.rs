use serde::{Deserialize, Serialize};
use std::ops::Index;
use std::sync::atomic::{AtomicUsize, Ordering};
use crate::sampling::SamplingParams;

#[derive(Debug, Clone, Copy, PartialEq, Eq, Deserialize, Serialize)]
pub enum SequenceStatus {
    Waiting,
    Running,
    Finished,
}

impl Default for SequenceStatus {
    fn default() -> Self {
        SequenceStatus::Waiting
    }
}

// A global counter to ensure each sequence gets a unique ID.
static SEQ_COUNTER: AtomicUsize = AtomicUsize::new(0);
fn next_seq_id() -> usize {
    SEQ_COUNTER.fetch_add(1, Ordering::Relaxed)
}

/// Represents a single request/sequence in the system.
///
/// This struct holds the state of a sequence, including its token IDs,
/// status, KV cache information, and sampling parameters.
/// It can be created with `Sequence::new` for new requests or deserialized
/// from a saved state.
#[derive(Debug, Clone, Deserialize, Serialize)]
pub struct Sequence {
    // --- Core Identifiers ---
    #[serde(default = "next_seq_id")]
    pub seq_id: usize,
    #[serde(default)]
    pub status: SequenceStatus,

    // --- Token Data ---
    pub token_ids: Vec<u32>,
    pub last_token_id: u32,
    pub num_tokens: usize,
    pub num_prompt_tokens: usize,

    // --- KV Cache Management ---
    #[serde(default)]
    pub num_cached_tokens: usize,
    // The list of physical block numbers in the KV cache.
    #[serde(default)]
    pub block_table: Vec<usize>,

    // --- Sampling Parameters ---
    pub temperature: f32,
    pub max_tokens: usize,
    pub ignore_eos: bool,
}

impl Sequence {
    /// The size of a block in the KV cache, in tokens.
    pub const BLOCK_SIZE: usize = 256;

    /// Creates a new sequence from a prompt and sampling parameters.
    pub fn new(token_ids: Vec<u32>, params: SamplingParams) -> Self {
        assert!(!token_ids.is_empty(), "Cannot create a sequence with empty token_ids");

        let num_tokens = token_ids.len();

        Self {
            seq_id: next_seq_id(),
            status: SequenceStatus::Waiting,
            // Safe to unwrap due to the assert above.
            last_token_id: *token_ids.last().unwrap(),
            num_prompt_tokens: num_tokens,
            num_tokens,
            token_ids,
            num_cached_tokens: 0,
            block_table: Vec::new(),
            temperature: params.temperature,
            max_tokens: params.max_tokens,
            ignore_eos: params.ignore_eos,
        }
    }

    /// Returns the total number of tokens in the sequence.
    pub fn len(&self) -> usize {
        self.num_tokens
    }

    /// Checks if the sequence is empty.
    pub fn is_empty(&self) -> bool {
        self.num_tokens == 0
    }

    /// Returns true if the sequence has finished generation.
    pub fn is_finished(&self) -> bool {
        self.status == SequenceStatus::Finished
    }

    /// The number of tokens generated by the model, excluding the prompt.
    pub fn num_completion_tokens(&self) -> usize {
        self.num_tokens - self.num_prompt_tokens
    }

    /// The token IDs of the prompt.
    pub fn prompt_token_ids(&self) -> &[u32] {
        &self.token_ids[..self.num_prompt_tokens]
    }

    /// The token IDs of the generated completion.
    pub fn completion_token_ids(&self) -> &[u32] {
        &self.token_ids[self.num_prompt_tokens..]
    }

    /// The number of blocks in the KV cache that are already computed and stored.
    pub fn num_cached_blocks(&self) -> usize {
        self.num_cached_tokens / Self::BLOCK_SIZE
    }

    /// The total number of blocks required to store the entire sequence.
    pub fn num_blocks(&self) -> usize {
        (self.num_tokens + Self::BLOCK_SIZE - 1) / Self::BLOCK_SIZE
    }

    /// The number of tokens in the last, possibly partially filled, block.
    pub fn last_block_num_tokens(&self) -> usize {
        let num_blocks = self.num_blocks();
        if num_blocks == 0 {
            0
        } else {
            self.num_tokens - (num_blocks - 1) * Self::BLOCK_SIZE
        }
    }

    /// Returns a slice of token IDs for the i-th block.
    /// Panics if the block index is out of bounds.
    pub fn block(&self, i: usize) -> &[u32] {
        assert!(i < self.num_blocks(), "Block index out of bounds");
        let start = i * Self::BLOCK_SIZE;
        let end = ((i + 1) * Self::BLOCK_SIZE).min(self.token_ids.len());
        &self.token_ids[start..end]
    }

    /// Appends a new token to the sequence, updating its state.
    pub fn append_token(&mut self, token_id: u32) {
        self.token_ids.push(token_id);
        self.last_token_id = token_id;
        self.num_tokens += 1;
    }
}

/// Allows for indexing the sequence's token IDs directly, e.g., `sequence[i]`.
impl Index<usize> for Sequence {
    type Output = u32;

    fn index(&self, index: usize) -> &Self::Output {
        &self.token_ids[index]
    }
}